# Checklist

### RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?
* RDBMS에서 길이가 일정하지 않은 값들을 넣을 때는 문자열일 경우에는 TEXT 타입을 이진문자로 되어 있는 경우는 BLOB 속성을 사용합니다. 만약에 레코드의 전체 데이터 크기가 64kb가 넘지 않는 한도 내에서는 VARCHAR(문자열)이나 VARBINARY(이진 데이터)를 사용해도 됩니다.

### RDBMS 테이블의 정규화는 무엇인가요?
* 정규화는 RDBMS 테이블의 데이터들이 중복되는 것을 막기 위해 데이터를 구조화하는 것을 말합니다.
* 정규화는 제1정규화(1NF) 부터 제6정규화(6NF)까지 6가지 규칙이 있으며 보통 제3정규화가 적용되었을 때 정규화가 되어있다고 할 수 있습니다.
* 1NF(제1정규화)가 적용되어 있다는 뜻은 테이블의 각 속성에는 값이 하나씩만 들어있고 중복되는 값들을 최소화 한다는 뜻이다.
* 2NF(제2정규화)는 key가 2개 이상인 테이블에서 다른 속성들은 전체 key에 종속되어야 한다는 규칙입니다.
* 3NF(제3정규화)는 key이외의 속성에 종속되어서는 안된다는 규칙을 의미합니다.

### MySQL 엔진에는 어떤 것들이 있나요?
* `MyISAM` : 5.5 이전 버전의 MYSQL의 기본 스토리지 엔진입니다. 기본적으로 인덱스에 대한 메모리 캐쉬가 지원되고 트갠잭션 기능이 없어서 sql 처리 도중 오류 문제에 취약한 면이 있습니다.

* `InnoDB` : 해당 엔진은 MYSQL 5.5 버전 이후 기본 스토리지 엔진으로 채택이 된 엔진입니다. 트랜잭션 기능이 제공되어 중간에 sql 처리 도중 오류가 생기면 이전 처리가 전부 무효화 된다는 특징이 있습니다. 또한 `버퍼 풀(디스크의 테이블 데이터와 키 정보를 캐쉬 해 놓는 공간)`이 지원되어 있어서 해당 엔진의 테이블에 데이터 처리에 버퍼링이 이용됩니다. 또한 오라클과 비슷하게 자동 에러 복구 기능이 탑재되어있으며, 기본 키를 이용한 클러스티드 제공 및 외래 키 제공 등 다양한 기능이 탑재되어 있습니다.

* `MEMORY` : 해당 엔진으로 제작된 테이블은 데이터를 전부 디스크에 저장합니다. 읽기,쓰기 속도가 매우 빠른 것이 특징이며, varchar 같은 가변형 속성과 text, blob 같은 대용량 속성은 사용하지를 못하고 char, binary 같은 고정형 속성만 사용이 가능합니다.

* `NDB 클러스터` : `NDB 클러스터`는 다른 엔진들과 구조면에서 차이가 나고 네트워크 기반으로 작동이 되며 가용성에 집중이 되어 있는 엔진입니다. NDB 클러스터는 관리 노드, 데이터 노드, SQL 노드 이 세개의 노드가 개별적으로 작동이 되며  한 노드에서 서로의 상태를 지속적으로 점검하여 한 노드에서 문제가 생겨 작동에 이상이 있을 경우 그 노드의 역할을 이어받는 페일오버(failover)를 합니다. 또한 `NDB 클러스터`는 메모리 기반의 엔진이면서도 주기적으로 디스크에 데이터를 백업을 합니다.

### RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
* 인덱싱이란 해당 데이터에 키(key)가 되는 속성을 붙이는 것을 말합니다. 인덱싱이 된 테이블은 인덱스(index)로 쓰이는 속성 key와 실질적으로 쓰이는 속성들이 쌍으로 이루어져있습니다. 또한 인덱스는 겹치는 값이 없어야 합니다.
* 인덱스가 존재하는 해당 테이블은 데이터를 넣을 때마다 테이블 안의 데이터들을 인덱스로 쓰이는 키(key)에 값에 따라 다시 정렬을 합니다. 
* 인덱싱을 사용하면 데이터를 삽입, 수정, 삭제할 때 걸리는 시간이 인덱싱을 하지 않았을 때 보다 증가하지만 반대로 이미 키(key)에 따라 정렬이 된 데이터들이기 때문에 검색 속도가 향상이 됩니다. 그래서 인덱싱은 데이터를 삽입, 수정, 삭제하는 경우보다 검색하여 사용하는 경우가 더 많은 테이블에 적용 시키는 것이 적합합니다.

### DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
* 암호를 평문으로 저장하지 않고도 인증이 가능한 이유는 비밀번호를 암호화시켜 저장했을때 처럼 똑같이 클라이언트에서 받은 비밀번호를 암호화시켜 비교하여 인증을 할 수 있기 때문입니다. 또한 `양방향 암호화` 방식으로 암호화를 했을 경우에는 복호화시켜 인증을 할 수도 있습니다.

# Quest
### 먼저 테이블이 어떻게 설계되어야 할지, 어떤 정보를 담고 있어야 할지 생각해 보세요

* Quest 12~13의 결과물을 MySQl 기반으로 테이블을 작성한다면 회원들의 정보를 기록하는 테이블(`user`)과 메모 파일의 정보를 저장하는 테이블(`memo`), 이렇게 두가지 테이블이 필요하다고 생각합니다.
* `user` 테이블
 - 테이블의 데이터들을 구분할 `idx`칼럼 : int형 데이터를 사용합니다.

 - 회원의 아이디를 저장할 `id`칼럼 : id는 사람마다 사용하는 문자와 길이가 다르므로 varchar형을 사용하는 것이 좋다고 생각합니다.

 - 회원의 별명을 저장할 `nickname`칼럼 : nickname도 id와 마찬가지로 varchar형을 사용하는 것이 좋다고 생각합니다.

 - 암호화된 회원의 암호를 저장할 `password`칼럼 : 암호화가 된 문자열들은 되기 전의 문자가 어떤 문자라도 항상 길이가 똑같으므로 char형를 사용하는 것이 가장 적합하다고 생각합니다.

 - 회원의 암호를 해쉬해서 인증할 때 같이 사용할 사용할 솔트 문자열을 저장할  `salt`칼럼 : salt는 정해진 길이만큼 문자열이 랜덤으로 생성하므로 이역시 cha형r를 사용하는 것이 적당하다고 생각합니다.


* `memo` 테이블
 - 메모 데이터들을 구분할 `idx`칼럼 : int형 데이터를 사용합니다.
 - 메모를 작성한 회원의 id를 저장할 `id`칼럼 : `user` 테이블과 마찬가지로 varchar형를 사용합니다.
 - 메모 데이터의 제목을 저장할 `title`칼럼 : title칼럼 역시 길이가 저장될 때마다 예측할 수 없으므로 넉넉한 최대길이의 varchar형로 설정하는 것이 좋다고 생각합니다.
 - 메모의 내용을 저장할  `content`칼럼 : 메모의 내용을 저장할 `content`칼럼은 무척 많은 양의 문자열이 들어갈 수도 있으므로 대용량 데이터 형식인 text형을 사용합니다.

### 사용자의 암호는 어떤 식으로 저장해야 할까요?
* 암호화 방법에는 `단방향 암호화`와 `양방향 암호화`가 있는데 `단방향 암호화`는 단방향 해시 함수를 통해 패스워드를 변환하여 암호화시키는 방법입니다. 이 방법으로 암호화시킨 패스워드는 복호화가 불가능하기 때문에 `양방향 암호화`보다 안전합니다.

* 하지만 동일한 패스워드를 입력하면 언제나 똑같은 값이 나온다는 점 때문에 단순한 비밀번호일수록 패스워드가 쉽게 발각이 된다는 단점이 있습니다. 그래서 `솔트(salt)`라는 이름의 임의의 문자열을 만들어서 원본 패스워드에 추가하여 암호화시키는 방법으로 패스워드를 알아내기 힘들게 만드는 방법이 있습니다. 또한 사용자마다 다른 솔트를 만들면 더욱더 패스워드가 들길 위험성이 줄어듭니다.

* `양방향 암호화`는 임의의 키를 만들어서 패스워드를 암호화하는 방법으로 이렇게 암호화된 패스워드는 나중에 만들어놓은 키를 이용해서 다시 복호화를 할 수 있기 때문에 암호화 방법과 키가 유출이 되면 쉽게 비밀번호도 유출이 된다는 문제점이 있습니다.

* 따라서 암호를 그대로 저장하지 않고 사용자의 `솔트(salt)문자열`을 만든 뒤에 암호와 솔트문자열을 조합해 해쉬를 하여 저장해야 한다고 생각 합니다.